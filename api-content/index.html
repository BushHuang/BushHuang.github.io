{"posts":[{"title":"手打的建图模板","content":"因为本人太懒，甚至懒得用vector建图😅，所以我就用OI邪教DILL的书中的知识写了一个很简单但能满足日常建图需要的模板。 代码： class graph { private: struct edge { int y,w; }; vector&lt;edge&gt;e[1001]; const int INF=1000000001; int n,m,indg[1001]; public: graph(int dn,int dm) { n=dn; m=dm; } void newedge(int x,int y,int w) { edge t; t.y=y; t.w=w; indg[y]++; e[x].push_back(t); return; } int outdegree(int x) { return e[x].size(); } int indegree(int x) { return indg[x]; } int edgelen(int x,int y) { for(int i=0;i&lt;e[x].size();i++) { if(e[x][i].y==y) return e[x][i].w; } return INF; } int edgelen_index(int x,int y) { return e[x][y].w; } }; 介绍一下其中的功能： 构造graph 使用graph(int n,int m)来创建一个graph。 这个graph可以有负权，但不能有重边。 n代表图的点数，m代表图的边数，当然，您也可以不填，但有些函数无法使用。 //Example1 graph A; graph B(4,5); 增边 使用newedge(int x,int y,int w)可以新增一条从x到y，权值为w的边。 //Example2 graph g; g.newedge(1,2,1); g.newedge(2,3,1); 查询结点入度/出度 使用indegree(int x)来查询结点x的入度。 使用outdegree(int x)来查询结点x的出度。 //Example3 graph g; g.newedge(1,2,1); g.newedge(2,3,1); printf(&quot;%d %d&quot;,g.indegree(2),g.outdegree(2)); 输出： 1 1 查询两直接相连结点之间的度数（方案一） 使用edgelen(int x,int y)来查询结点x到结点y的权值。如果两点不直接连接，则返回 109+110^9+1109+1。 //Example4 graph g; g.newedge(1,2,1); g.newedge(2,3,1); printf(&quot;%d %d&quot;,g.edgelen(1,2),g.edgelen(1,3)); 输出： 1 1000000001 查询两直接相连结点之间的度数（方案二） 使用edgelen_index(int x,int y)来查询结点x到结点x的第y个下家的权值。如果两点不直接连接，则返回 109+110^9+1109+1 。 🔔 结点x的第y个下家是指此结点与结点x增边时结点x已经与(y-1)个点连接。 //Example4 graph g; g.newedge(1,2,1); g.newedge(1,3,2); g.newedge(2,3,1); printf(&quot;%d %d&quot;,g.edgelen_index(1,1),g.edgelen_index(1,2)); 输出： 1 2 ","link":"https://BushHuang.github.io/post/shou-da-de-jian-tu-mo-ban/"},{"title":"CF761B Dasha and friends 题解","content":"题目大意：给定两个环，判断它们是否相同。 此题数据量并不大 (1≤n≤50,n≤L≤100)(1\\le n\\le 50,n\\le L\\le 100)(1≤n≤50,n≤L≤100), 因此可以使用暴力的方式： 通过旋转 AAA 环，每次将环上的第 iii 个元素移到第 i+1i+1i+1 个位置(最后一个元素移到第一个元素的位置），并将旋转完毕后的 AAA 环与 BBB 环相比较，即可得出正解。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int n,l,x,t; bool a[100],b[100],flag; //AB两环 (bool型,1表示有障碍物,0表示没有障碍物) int main() { cin&gt;&gt;n&gt;&gt;l; for(int i=1;i&lt;=n;i++) //输入A,B两环 { cin&gt;&gt;x; a[x]=true; } for(int i=1;i&lt;=n;i++) { cin&gt;&gt;x; b[x]=true; } for(int i=1;i&lt;=l;i++) { t=a[l-1]; //将最后一个元素存下来 for(int j=l-1;j&gt;=1;j--) //将第j个元素移到j+1的位置 { a[j]=a[j-1]; } a[0]=t; //把最后一个元素存到第一个位置 flag=true; for(int j=0;j&lt;l;j++) //判断A环是否与B环相同 { if(a[j]!=b[j]) flag=false; } if(flag) { cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; //如果相同输出&quot;YES&quot; return 0; } } cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; //如果转了一圈还没有重合输出&quot;NO&quot; return 0; } ","link":"https://BushHuang.github.io/post/cf761b-solution/"},{"title":"P8760 填空问题 题解","content":"这是一个寻找规律题。 首先，我们制作一个可以寻找前 nnn 个斐波那契数列的数个位的程序： #include&lt;bits/stdc++.h&gt; using namespace std; int a=1,b=1,c; //由于只取个位，所以不需要考虑爆long long的问题 long long n; int main() { cin&gt;&gt;n; cout&lt;&lt;&quot;1 1 &quot;; //前两个数 for(int i=1;i&lt;=n;i++) { c=(a+b)%10; //每次只取个位 cout&lt;&lt;c&lt;&lt;&quot; &quot;; a=b; b=c; } return 0; } 输入 100010001000 试试： 很明显，这是一个周期为 606060 的数列，其中“777”出现了 888 次。 计算可得答案： ⌊20220201120060⌋×8=26960268160\\left \\lfloor\\frac{202202011200}{60} \\right \\rfloor \\times 8 = 26960268160 ⌊60202202011200​⌋×8=26960268160 ","link":"https://BushHuang.github.io/post/p8760-solution/"}]}